// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock_auth

import (
	"context"

	mock "github.com/stretchr/testify/mock"
	"github.com/xsqrty/notes/internal/domain/auth"
	"github.com/xsqrty/notes/internal/domain/user"
)

// NewTokenizer creates a new instance of Tokenizer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTokenizer(t interface {
	mock.TestingT
	Cleanup(func())
}) *Tokenizer {
	mock := &Tokenizer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Tokenizer is an autogenerated mock type for the Tokenizer type
type Tokenizer struct {
	mock.Mock
}

type Tokenizer_Expecter struct {
	mock *mock.Mock
}

func (_m *Tokenizer) EXPECT() *Tokenizer_Expecter {
	return &Tokenizer_Expecter{mock: &_m.Mock}
}

// CreateAccessToken provides a mock function for the type Tokenizer
func (_mock *Tokenizer) CreateAccessToken(user1 *user.User) (string, error) {
	ret := _mock.Called(user1)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccessToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*user.User) (string, error)); ok {
		return returnFunc(user1)
	}
	if returnFunc, ok := ret.Get(0).(func(*user.User) string); ok {
		r0 = returnFunc(user1)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(*user.User) error); ok {
		r1 = returnFunc(user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Tokenizer_CreateAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccessToken'
type Tokenizer_CreateAccessToken_Call struct {
	*mock.Call
}

// CreateAccessToken is a helper method to define mock.On call
//   - user1 *user.User
func (_e *Tokenizer_Expecter) CreateAccessToken(user1 interface{}) *Tokenizer_CreateAccessToken_Call {
	return &Tokenizer_CreateAccessToken_Call{Call: _e.mock.On("CreateAccessToken", user1)}
}

func (_c *Tokenizer_CreateAccessToken_Call) Run(run func(user1 *user.User)) *Tokenizer_CreateAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *user.User
		if args[0] != nil {
			arg0 = args[0].(*user.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tokenizer_CreateAccessToken_Call) Return(s string, err error) *Tokenizer_CreateAccessToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Tokenizer_CreateAccessToken_Call) RunAndReturn(run func(user1 *user.User) (string, error)) *Tokenizer_CreateAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRefreshToken provides a mock function for the type Tokenizer
func (_mock *Tokenizer) CreateRefreshToken(user1 *user.User) (string, error) {
	ret := _mock.Called(user1)

	if len(ret) == 0 {
		panic("no return value specified for CreateRefreshToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*user.User) (string, error)); ok {
		return returnFunc(user1)
	}
	if returnFunc, ok := ret.Get(0).(func(*user.User) string); ok {
		r0 = returnFunc(user1)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(*user.User) error); ok {
		r1 = returnFunc(user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Tokenizer_CreateRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRefreshToken'
type Tokenizer_CreateRefreshToken_Call struct {
	*mock.Call
}

// CreateRefreshToken is a helper method to define mock.On call
//   - user1 *user.User
func (_e *Tokenizer_Expecter) CreateRefreshToken(user1 interface{}) *Tokenizer_CreateRefreshToken_Call {
	return &Tokenizer_CreateRefreshToken_Call{Call: _e.mock.On("CreateRefreshToken", user1)}
}

func (_c *Tokenizer_CreateRefreshToken_Call) Run(run func(user1 *user.User)) *Tokenizer_CreateRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *user.User
		if args[0] != nil {
			arg0 = args[0].(*user.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Tokenizer_CreateRefreshToken_Call) Return(s string, err error) *Tokenizer_CreateRefreshToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *Tokenizer_CreateRefreshToken_Call) RunAndReturn(run func(user1 *user.User) (string, error)) *Tokenizer_CreateRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewPasswordGenerator creates a new instance of PasswordGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPasswordGenerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *PasswordGenerator {
	mock := &PasswordGenerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PasswordGenerator is an autogenerated mock type for the PasswordGenerator type
type PasswordGenerator struct {
	mock.Mock
}

type PasswordGenerator_Expecter struct {
	mock *mock.Mock
}

func (_m *PasswordGenerator) EXPECT() *PasswordGenerator_Expecter {
	return &PasswordGenerator_Expecter{mock: &_m.Mock}
}

// Compare provides a mock function for the type PasswordGenerator
func (_mock *PasswordGenerator) Compare(hash string, password string) bool {
	ret := _mock.Called(hash, password)

	if len(ret) == 0 {
		panic("no return value specified for Compare")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = returnFunc(hash, password)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// PasswordGenerator_Compare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Compare'
type PasswordGenerator_Compare_Call struct {
	*mock.Call
}

// Compare is a helper method to define mock.On call
//   - hash string
//   - password string
func (_e *PasswordGenerator_Expecter) Compare(hash interface{}, password interface{}) *PasswordGenerator_Compare_Call {
	return &PasswordGenerator_Compare_Call{Call: _e.mock.On("Compare", hash, password)}
}

func (_c *PasswordGenerator_Compare_Call) Run(run func(hash string, password string)) *PasswordGenerator_Compare_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *PasswordGenerator_Compare_Call) Return(b bool) *PasswordGenerator_Compare_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *PasswordGenerator_Compare_Call) RunAndReturn(run func(hash string, password string) bool) *PasswordGenerator_Compare_Call {
	_c.Call.Return(run)
	return _c
}

// Generate provides a mock function for the type PasswordGenerator
func (_mock *PasswordGenerator) Generate(s string) (string, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for Generate")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PasswordGenerator_Generate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Generate'
type PasswordGenerator_Generate_Call struct {
	*mock.Call
}

// Generate is a helper method to define mock.On call
//   - s string
func (_e *PasswordGenerator_Expecter) Generate(s interface{}) *PasswordGenerator_Generate_Call {
	return &PasswordGenerator_Generate_Call{Call: _e.mock.On("Generate", s)}
}

func (_c *PasswordGenerator_Generate_Call) Run(run func(s string)) *PasswordGenerator_Generate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PasswordGenerator_Generate_Call) Return(s1 string, err error) *PasswordGenerator_Generate_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *PasswordGenerator_Generate_Call) RunAndReturn(run func(s string) (string, error)) *PasswordGenerator_Generate_Call {
	_c.Call.Return(run)
	return _c
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
	mock.TestingT
	Cleanup(func())
}) *Service {
	mock := &Service{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

type Service_Expecter struct {
	mock *mock.Mock
}

func (_m *Service) EXPECT() *Service_Expecter {
	return &Service_Expecter{mock: &_m.Mock}
}

// GenerateTokens provides a mock function for the type Service
func (_mock *Service) GenerateTokens(user1 *user.User) (*auth.Tokens, error) {
	ret := _mock.Called(user1)

	if len(ret) == 0 {
		panic("no return value specified for GenerateTokens")
	}

	var r0 *auth.Tokens
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*user.User) (*auth.Tokens, error)); ok {
		return returnFunc(user1)
	}
	if returnFunc, ok := ret.Get(0).(func(*user.User) *auth.Tokens); ok {
		r0 = returnFunc(user1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auth.Tokens)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*user.User) error); ok {
		r1 = returnFunc(user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_GenerateTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateTokens'
type Service_GenerateTokens_Call struct {
	*mock.Call
}

// GenerateTokens is a helper method to define mock.On call
//   - user1 *user.User
func (_e *Service_Expecter) GenerateTokens(user1 interface{}) *Service_GenerateTokens_Call {
	return &Service_GenerateTokens_Call{Call: _e.mock.On("GenerateTokens", user1)}
}

func (_c *Service_GenerateTokens_Call) Run(run func(user1 *user.User)) *Service_GenerateTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *user.User
		if args[0] != nil {
			arg0 = args[0].(*user.User)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Service_GenerateTokens_Call) Return(tokens *auth.Tokens, err error) *Service_GenerateTokens_Call {
	_c.Call.Return(tokens, err)
	return _c
}

func (_c *Service_GenerateTokens_Call) RunAndReturn(run func(user1 *user.User) (*auth.Tokens, error)) *Service_GenerateTokens_Call {
	_c.Call.Return(run)
	return _c
}

// Login provides a mock function for the type Service
func (_mock *Service) Login(ctx context.Context, login *auth.Login) (*auth.Tokens, error) {
	ret := _mock.Called(ctx, login)

	if len(ret) == 0 {
		panic("no return value specified for Login")
	}

	var r0 *auth.Tokens
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.Login) (*auth.Tokens, error)); ok {
		return returnFunc(ctx, login)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.Login) *auth.Tokens); ok {
		r0 = returnFunc(ctx, login)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auth.Tokens)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.Login) error); ok {
		r1 = returnFunc(ctx, login)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type Service_Login_Call struct {
	*mock.Call
}

// Login is a helper method to define mock.On call
//   - ctx context.Context
//   - login *auth.Login
func (_e *Service_Expecter) Login(ctx interface{}, login interface{}) *Service_Login_Call {
	return &Service_Login_Call{Call: _e.mock.On("Login", ctx, login)}
}

func (_c *Service_Login_Call) Run(run func(ctx context.Context, login *auth.Login)) *Service_Login_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.Login
		if args[1] != nil {
			arg1 = args[1].(*auth.Login)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Service_Login_Call) Return(tokens *auth.Tokens, err error) *Service_Login_Call {
	_c.Call.Return(tokens, err)
	return _c
}

func (_c *Service_Login_Call) RunAndReturn(run func(ctx context.Context, login *auth.Login) (*auth.Tokens, error)) *Service_Login_Call {
	_c.Call.Return(run)
	return _c
}

// SignUp provides a mock function for the type Service
func (_mock *Service) SignUp(ctx context.Context, user1 *auth.SignUp) (*auth.Tokens, error) {
	ret := _mock.Called(ctx, user1)

	if len(ret) == 0 {
		panic("no return value specified for SignUp")
	}

	var r0 *auth.Tokens
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.SignUp) (*auth.Tokens, error)); ok {
		return returnFunc(ctx, user1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *auth.SignUp) *auth.Tokens); ok {
		r0 = returnFunc(ctx, user1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*auth.Tokens)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *auth.SignUp) error); ok {
		r1 = returnFunc(ctx, user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_SignUp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignUp'
type Service_SignUp_Call struct {
	*mock.Call
}

// SignUp is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *auth.SignUp
func (_e *Service_Expecter) SignUp(ctx interface{}, user1 interface{}) *Service_SignUp_Call {
	return &Service_SignUp_Call{Call: _e.mock.On("SignUp", ctx, user1)}
}

func (_c *Service_SignUp_Call) Run(run func(ctx context.Context, user1 *auth.SignUp)) *Service_SignUp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *auth.SignUp
		if args[1] != nil {
			arg1 = args[1].(*auth.SignUp)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Service_SignUp_Call) Return(tokens *auth.Tokens, err error) *Service_SignUp_Call {
	_c.Call.Return(tokens, err)
	return _c
}

func (_c *Service_SignUp_Call) RunAndReturn(run func(ctx context.Context, user1 *auth.SignUp) (*auth.Tokens, error)) *Service_SignUp_Call {
	_c.Call.Return(run)
	return _c
}
