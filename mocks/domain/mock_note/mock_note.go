// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mock_note

import (
	"context"

	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
	"github.com/xsqrty/notes/internal/domain/note"
	"github.com/xsqrty/notes/internal/domain/search"
	"github.com/xsqrty/notes/internal/domain/user"
	"github.com/xsqrty/notes/pkg/rbac"
)

// NewGuarder creates a new instance of Guarder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGuarder(t interface {
	mock.TestingT
	Cleanup(func())
}) *Guarder {
	mock := &Guarder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Guarder is an autogenerated mock type for the Guarder type
type Guarder struct {
	mock.Mock
}

type Guarder_Expecter struct {
	mock *mock.Mock
}

func (_m *Guarder) EXPECT() *Guarder_Expecter {
	return &Guarder_Expecter{mock: &_m.Mock}
}

// IsGranted provides a mock function for the type Guarder
func (_mock *Guarder) IsGranted(ctx context.Context, op rbac.Operation, note1 *note.Note, user1 *user.User) (bool, error) {
	ret := _mock.Called(ctx, op, note1, user1)

	if len(ret) == 0 {
		panic("no return value specified for IsGranted")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, rbac.Operation, *note.Note, *user.User) (bool, error)); ok {
		return returnFunc(ctx, op, note1, user1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, rbac.Operation, *note.Note, *user.User) bool); ok {
		r0 = returnFunc(ctx, op, note1, user1)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, rbac.Operation, *note.Note, *user.User) error); ok {
		r1 = returnFunc(ctx, op, note1, user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Guarder_IsGranted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsGranted'
type Guarder_IsGranted_Call struct {
	*mock.Call
}

// IsGranted is a helper method to define mock.On call
//   - ctx context.Context
//   - op rbac.Operation
//   - note1 *note.Note
//   - user1 *user.User
func (_e *Guarder_Expecter) IsGranted(ctx interface{}, op interface{}, note1 interface{}, user1 interface{}) *Guarder_IsGranted_Call {
	return &Guarder_IsGranted_Call{Call: _e.mock.On("IsGranted", ctx, op, note1, user1)}
}

func (_c *Guarder_IsGranted_Call) Run(run func(ctx context.Context, op rbac.Operation, note1 *note.Note, user1 *user.User)) *Guarder_IsGranted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 rbac.Operation
		if args[1] != nil {
			arg1 = args[1].(rbac.Operation)
		}
		var arg2 *note.Note
		if args[2] != nil {
			arg2 = args[2].(*note.Note)
		}
		var arg3 *user.User
		if args[3] != nil {
			arg3 = args[3].(*user.User)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *Guarder_IsGranted_Call) Return(b bool, err error) *Guarder_IsGranted_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Guarder_IsGranted_Call) RunAndReturn(run func(ctx context.Context, op rbac.Operation, note1 *note.Note, user1 *user.User) (bool, error)) *Guarder_IsGranted_Call {
	_c.Call.Return(run)
	return _c
}

// NewRepository creates a new instance of Repository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repository {
	mock := &Repository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
	mock.Mock
}

type Repository_Expecter struct {
	mock *mock.Mock
}

func (_m *Repository) EXPECT() *Repository_Expecter {
	return &Repository_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type Repository
func (_mock *Repository) Delete(ctx context.Context, n *note.Note) error {
	ret := _mock.Called(ctx, n)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *note.Note) error); ok {
		r0 = returnFunc(ctx, n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Repository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - n *note.Note
func (_e *Repository_Expecter) Delete(ctx interface{}, n interface{}) *Repository_Delete_Call {
	return &Repository_Delete_Call{Call: _e.mock.On("Delete", ctx, n)}
}

func (_c *Repository_Delete_Call) Run(run func(ctx context.Context, n *note.Note)) *Repository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *note.Note
		if args[1] != nil {
			arg1 = args[1].(*note.Note)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_Delete_Call) Return(err error) *Repository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_Delete_Call) RunAndReturn(run func(ctx context.Context, n *note.Note) error) *Repository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type Repository
func (_mock *Repository) GetByID(ctx context.Context, id uuid.UUID) (*note.Note, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *note.Note
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*note.Note, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *note.Note); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*note.Note)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type Repository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *Repository_Expecter) GetByID(ctx interface{}, id interface{}) *Repository_GetByID_Call {
	return &Repository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *Repository_GetByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *Repository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_GetByID_Call) Return(note1 *note.Note, err error) *Repository_GetByID_Call {
	_c.Call.Return(note1, err)
	return _c
}

func (_c *Repository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*note.Note, error)) *Repository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// IDExists provides a mock function for the type Repository
func (_mock *Repository) IDExists(ctx context.Context, id uuid.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for IDExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_IDExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IDExists'
type Repository_IDExists_Call struct {
	*mock.Call
}

// IDExists is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *Repository_Expecter) IDExists(ctx interface{}, id interface{}) *Repository_IDExists_Call {
	return &Repository_IDExists_Call{Call: _e.mock.On("IDExists", ctx, id)}
}

func (_c *Repository_IDExists_Call) Run(run func(ctx context.Context, id uuid.UUID)) *Repository_IDExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_IDExists_Call) Return(b bool, err error) *Repository_IDExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Repository_IDExists_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (bool, error)) *Repository_IDExists_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type Repository
func (_mock *Repository) Save(ctx context.Context, n *note.Note) error {
	ret := _mock.Called(ctx, n)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *note.Note) error); ok {
		r0 = returnFunc(ctx, n)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Repository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type Repository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
//   - n *note.Note
func (_e *Repository_Expecter) Save(ctx interface{}, n interface{}) *Repository_Save_Call {
	return &Repository_Save_Call{Call: _e.mock.On("Save", ctx, n)}
}

func (_c *Repository_Save_Call) Run(run func(ctx context.Context, n *note.Note)) *Repository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *note.Note
		if args[1] != nil {
			arg1 = args[1].(*note.Note)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Repository_Save_Call) Return(err error) *Repository_Save_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Repository_Save_Call) RunAndReturn(run func(ctx context.Context, n *note.Note) error) *Repository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SearchByUser provides a mock function for the type Repository
func (_mock *Repository) SearchByUser(ctx context.Context, u *user.User, r *search.Request) (*search.Result[note.Note], error) {
	ret := _mock.Called(ctx, u, r)

	if len(ret) == 0 {
		panic("no return value specified for SearchByUser")
	}

	var r0 *search.Result[note.Note]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *search.Request) (*search.Result[note.Note], error)); ok {
		return returnFunc(ctx, u, r)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *search.Request) *search.Result[note.Note]); ok {
		r0 = returnFunc(ctx, u, r)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*search.Result[note.Note])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, *search.Request) error); ok {
		r1 = returnFunc(ctx, u, r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Repository_SearchByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchByUser'
type Repository_SearchByUser_Call struct {
	*mock.Call
}

// SearchByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - u *user.User
//   - r *search.Request
func (_e *Repository_Expecter) SearchByUser(ctx interface{}, u interface{}, r interface{}) *Repository_SearchByUser_Call {
	return &Repository_SearchByUser_Call{Call: _e.mock.On("SearchByUser", ctx, u, r)}
}

func (_c *Repository_SearchByUser_Call) Run(run func(ctx context.Context, u *user.User, r *search.Request)) *Repository_SearchByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 *search.Request
		if args[2] != nil {
			arg2 = args[2].(*search.Request)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Repository_SearchByUser_Call) Return(result *search.Result[note.Note], err error) *Repository_SearchByUser_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *Repository_SearchByUser_Call) RunAndReturn(run func(ctx context.Context, u *user.User, r *search.Request) (*search.Result[note.Note], error)) *Repository_SearchByUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewService creates a new instance of Service. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewService(t interface {
	mock.TestingT
	Cleanup(func())
}) *Service {
	mock := &Service{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

type Service_Expecter struct {
	mock *mock.Mock
}

func (_m *Service) EXPECT() *Service_Expecter {
	return &Service_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type Service
func (_mock *Service) Create(ctx context.Context, user1 *user.User, data *note.CreateData) (*note.Note, error) {
	ret := _mock.Called(ctx, user1, data)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *note.Note
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *note.CreateData) (*note.Note, error)); ok {
		return returnFunc(ctx, user1, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *note.CreateData) *note.Note); ok {
		r0 = returnFunc(ctx, user1, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*note.Note)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, *note.CreateData) error); ok {
		r1 = returnFunc(ctx, user1, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Service_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
//   - data *note.CreateData
func (_e *Service_Expecter) Create(ctx interface{}, user1 interface{}, data interface{}) *Service_Create_Call {
	return &Service_Create_Call{Call: _e.mock.On("Create", ctx, user1, data)}
}

func (_c *Service_Create_Call) Run(run func(ctx context.Context, user1 *user.User, data *note.CreateData)) *Service_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 *note.CreateData
		if args[2] != nil {
			arg2 = args[2].(*note.CreateData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Service_Create_Call) Return(note1 *note.Note, err error) *Service_Create_Call {
	_c.Call.Return(note1, err)
	return _c
}

func (_c *Service_Create_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User, data *note.CreateData) (*note.Note, error)) *Service_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type Service
func (_mock *Service) Delete(ctx context.Context, user1 *user.User, id uuid.UUID) (*note.Note, error) {
	ret := _mock.Called(ctx, user1, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 *note.Note
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, uuid.UUID) (*note.Note, error)); ok {
		return returnFunc(ctx, user1, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, uuid.UUID) *note.Note); ok {
		r0 = returnFunc(ctx, user1, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*note.Note)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, user1, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Service_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
//   - id uuid.UUID
func (_e *Service_Expecter) Delete(ctx interface{}, user1 interface{}, id interface{}) *Service_Delete_Call {
	return &Service_Delete_Call{Call: _e.mock.On("Delete", ctx, user1, id)}
}

func (_c *Service_Delete_Call) Run(run func(ctx context.Context, user1 *user.User, id uuid.UUID)) *Service_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 uuid.UUID
		if args[2] != nil {
			arg2 = args[2].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Service_Delete_Call) Return(note1 *note.Note, err error) *Service_Delete_Call {
	_c.Call.Return(note1, err)
	return _c
}

func (_c *Service_Delete_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User, id uuid.UUID) (*note.Note, error)) *Service_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type Service
func (_mock *Service) Get(ctx context.Context, user1 *user.User, id uuid.UUID) (*note.Note, error) {
	ret := _mock.Called(ctx, user1, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *note.Note
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, uuid.UUID) (*note.Note, error)); ok {
		return returnFunc(ctx, user1, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, uuid.UUID) *note.Note); ok {
		r0 = returnFunc(ctx, user1, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*note.Note)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, user1, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Service_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
//   - id uuid.UUID
func (_e *Service_Expecter) Get(ctx interface{}, user1 interface{}, id interface{}) *Service_Get_Call {
	return &Service_Get_Call{Call: _e.mock.On("Get", ctx, user1, id)}
}

func (_c *Service_Get_Call) Run(run func(ctx context.Context, user1 *user.User, id uuid.UUID)) *Service_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 uuid.UUID
		if args[2] != nil {
			arg2 = args[2].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Service_Get_Call) Return(note1 *note.Note, err error) *Service_Get_Call {
	_c.Call.Return(note1, err)
	return _c
}

func (_c *Service_Get_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User, id uuid.UUID) (*note.Note, error)) *Service_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Search provides a mock function for the type Service
func (_mock *Service) Search(ctx context.Context, user1 *user.User, req *search.Request) (*search.Result[note.Note], error) {
	ret := _mock.Called(ctx, user1, req)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 *search.Result[note.Note]
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *search.Request) (*search.Result[note.Note], error)); ok {
		return returnFunc(ctx, user1, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *search.Request) *search.Result[note.Note]); ok {
		r0 = returnFunc(ctx, user1, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*search.Result[note.Note])
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, *search.Request) error); ok {
		r1 = returnFunc(ctx, user1, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type Service_Search_Call struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
//   - req *search.Request
func (_e *Service_Expecter) Search(ctx interface{}, user1 interface{}, req interface{}) *Service_Search_Call {
	return &Service_Search_Call{Call: _e.mock.On("Search", ctx, user1, req)}
}

func (_c *Service_Search_Call) Run(run func(ctx context.Context, user1 *user.User, req *search.Request)) *Service_Search_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 *search.Request
		if args[2] != nil {
			arg2 = args[2].(*search.Request)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Service_Search_Call) Return(result *search.Result[note.Note], err error) *Service_Search_Call {
	_c.Call.Return(result, err)
	return _c
}

func (_c *Service_Search_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User, req *search.Request) (*search.Result[note.Note], error)) *Service_Search_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type Service
func (_mock *Service) Update(ctx context.Context, user1 *user.User, data *note.UpdateData) (*note.Note, error) {
	ret := _mock.Called(ctx, user1, data)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *note.Note
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *note.UpdateData) (*note.Note, error)); ok {
		return returnFunc(ctx, user1, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User, *note.UpdateData) *note.Note); ok {
		r0 = returnFunc(ctx, user1, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*note.Note)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User, *note.UpdateData) error); ok {
		r1 = returnFunc(ctx, user1, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Service_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Service_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
//   - data *note.UpdateData
func (_e *Service_Expecter) Update(ctx interface{}, user1 interface{}, data interface{}) *Service_Update_Call {
	return &Service_Update_Call{Call: _e.mock.On("Update", ctx, user1, data)}
}

func (_c *Service_Update_Call) Run(run func(ctx context.Context, user1 *user.User, data *note.UpdateData)) *Service_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		var arg2 *note.UpdateData
		if args[2] != nil {
			arg2 = args[2].(*note.UpdateData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Service_Update_Call) Return(note1 *note.Note, err error) *Service_Update_Call {
	_c.Call.Return(note1, err)
	return _c
}

func (_c *Service_Update_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User, data *note.UpdateData) (*note.Note, error)) *Service_Update_Call {
	_c.Call.Return(run)
	return _c
}
